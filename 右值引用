1 右值引用
  C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：
  （1）可以取地址的，有名字的，非临时的就是左值。
  （2）不能取地址的，没有名字的，临时的就是右值。
  因此，立即数、函数返回的值 等 都是右值；而非匿名对象（包括变量）、函数返回的引用、const对象都是左值。
  从本质上讲：
      创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值（包括立即数）；
      而用户创建的，通过作用域规则可知其生存期的，就是左值（包括函数返回的局部变量的引用以及const对象）。
  
  右值引用是C++11新增的特性。
  右值引用绑定到右值，绑定到右值以后，本来被销毁的右值的生存期会延长。
  
  在汇编层面，右值引用和常引用做的事情是一样的，都是产生临时变量来存储常量。唯一一点区别是：右值引用可以进行读写操作，而常引用只能进行读操作。
  右值引用的存在并不是为了取代左值引用，而是充分利用右值的构造来减少对象构造和析构操作 以达到提升效率的目的。
 
2 forward关键字
  目的：保持住参数的右值属性。
  背景：模板函数中的推导类型，作为另一个函数的参数时，不管实参是什么类型，作为另一个参数的实参时，都变成了左值。
       因为C++里规定：不管调用方的实参是否是右值，函数的形参就是左值。
       所以，调用一个函数的形参即使用 T&& arg 来声明，传过去的也是左值，编译不过，因为不能自动把左值转化为右值，除非使用std::move。
  示例：   
    template<typename F, typename T1, typename T2>
    void my_fun(F f, T1& t1, T2&& t2) {
        f(std::forward<T2>(t2), std::forward<T1>(t1)); // OK
        // f(t2,t2);    // ERROR
        // f(std::move(t2), t1);    // OK
    }
    int main() {
        int i = 1;
        int h = 2;
        my_fun(f1, i, std::move(h));
        std::cout << "h: " << h << ", i:" << i << std::endl;
        return 0;
    }
